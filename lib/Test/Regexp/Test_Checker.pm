package Test::Regexp::Test_Checker;

#
# A bunch of subroutines to help testing Test::Regexp
#

use 5.038;

use strict;
use warnings;
no  warnings 'syntax';

use Test::More;
use Exporter ();
our @ISA    = qw [Exporter];
our @EXPORT = qw [run_tests];

END {
    done_testing;
}

#
# Given the output of a test, split it into multiple parts:
#   - outer:    Lines not related to the inner subtests
#   - subtest:  Sets of lines each belonging to a specific subtest
#   - trail:    Summary of the subtests
#
my sub split_into_subtests ($output) {
    my $subtests = [];
    my $subtest  = [];
    my $trail    = [];
    my $indent   = " " x 4;

    my $outer = [grep {!/^$indent/} @$output];
    my $inner = [grep { /^$indent/} @$output];
    
    foreach my $i (keys @$inner) {
        my $line = $$inner [$i];
        if ($line =~ /^${indent}1\.\.([0-9]+)/) {
            #
            # This signals the end of the subtests. 
            # Collect this line, and anything which may follow.
            #
            push @$subtests => $subtest;
            $trail = [@$inner [$i .. $#$inner]];
            last;
        }
        if ($line =~ /^${indent}# Subtest/) {
            # Beginning of a subject. Start a new one.
            push @$subtests => $subtest if @$subtest;
            $subtest = [];
        }
        push @$subtest => $line;
    }

    #
    # Remove leading indents
    #
    s/^\s+// for @$outer, @$trail;
    foreach my $subtest (@$subtests) {
        s/^\s+// for @$subtest;
    }

    return $outer, $subtests, $trail
}

#
# Given a set of messages, return the number of reported tests
# as generated by done_testing ()
#
my sub reported_tests ($output) {
    foreach my $line (reverse @$output) {
        return 0 + $1 if $line =~ /^\s*1\.\.([0-9]+)/;
    }
}

#
# Given a number, extract the result of the test with that number,
# its message, and, the errors, if any.
#
my sub extract_test ($output, $test_nr) {
    foreach my $i (keys @$output) {
        my $line = $$output [$i] =~ s/^\s+//r;
        if ($line =~ /^(not )?ok $test_nr\s+-\s*(.*)/) {
            my $result  = $1 ? 0 : 1;
            my $message = $2;
            my $errors  = [];

            $i ++;
            while ($$output [$i] && $$output [$i] =~ /^\s*#/) {
                push @$errors => $$output [$i] =~ s/^\s+//r;
                $i ++;
            }
            return $result, $message, $errors;
        }
    }
}

#
# Return the number of tests in a set. This assumes there will
# not be subtests.
#
my sub nr_of_tests ($output) {
    my $nr_of_tests = 0;
    foreach my $line (@$output) {
        $line =~ /^(?:not )?ok ([0-9]+)/ or next;
        $nr_of_tests = $1 if $1 > $nr_of_tests;
    }
    $nr_of_tests;
}


#
# Check the reporting of a single test:
#   - Expected ok/not ok
#   - Expected test message
#   - Does it have error message?
#
my sub check_single_result (%args) {
    my $output      = $args {output};
    my $exp_result  = $args {exp_result} =~ /y/i ? 1 : 0;
    my $test_nr     = $args {test_nr};
    my $name        = $args {name};
    my $exp_message = $args {exp_message};

    my ($got_result, $got_message, $got_errors) =
                      extract_test $output, $test_nr;

    subtest $name => sub {
        cmp_ok $got_result, '==',  $exp_result,
                   "Test is a " . ($exp_result ? "pass" : "fail");
        if ($exp_message) {
            if (ref $exp_message) {
                like $got_message, $exp_message, "Test message"
            }
            else {
                is   $got_message, $exp_message, "Test message"
            }
        }
        cmp_ok scalar @$got_errors,
                       $exp_result ? "==" : ">", 0,
                       $exp_result ? "No failure messages"
                                   : "Has failure messages";
    };
}


#
# Check the lines which are not part of subtests.
#
my sub check_outer ($output, $match, $exp) {
    my $subject = $$match {subject};
    my $pattern = $$match {pattern};
    subtest ("Checking overal reporting" => sub {
        my  $start_got = $$output [0];
        my  $start_exp = qq {# Subtest: Matching "$subject" } .
                         qq {against /$pattern/};
        is ($start_got, $start_exp, "Starting line");

        is reported_tests ($output), 1, "Number of reported tests";

        if ($exp =~ /n/i) {
            like $$output [-1], qr/^# Looks like you failed 1 test of 1\./,
                 "Failure message";
        }
        else {
            like $$output [-1], qr /^[^#]/, "No failure message";
        }
    });
}

#
# Check whether the pattern matches at all. Should be at most 2 tests
#
my sub check_match ($output, $exp, $match) {
    state $names = [
        "Pattern matches",
        "Match is complete"
    ];
    subtest "Checking Match subtest" => sub {
        like $$output [0], qr /^# Subtest: Match/, "Correct header";
        my @exp = split // => $exp;

        is reported_tests ($output), length ($exp),
             "Number of reported tests";

        foreach my $i (keys @exp) {
            check_single_result output      => $output,
                                exp_result  => $exp [$i],
                                test_nr     => $i + 1,
                                name        => $$names [$i],
                                exp_message => $$names [$i];
        }

        is (scalar (@exp), nr_of_tests ($output), "Expected number of tests");
    }
}

my sub check_named ($output, $exp, $match) {
    my $captures = [grep {ref $_} @{$$match {captures} || []}];

    subtest "Checking Named Captures subtest" => sub {
        like $$output [0], qr /^# Subtest: Named captures$/,
                           "Correct header";
        my @exp = split // => $exp;

        is reported_tests ($output), length ($exp), "Number of reported tests";

        if (@exp == 1) {
            check_single_result output      => $output,
                                test_nr     => 1,
                                exp_result  => $exp [0],
                                name        => "No named captures",
                                exp_message => "No named captures",
            ;
        }
        else {
            my %names;
            foreach my $capture (@$captures) {
                my ($key, $value) = @$capture;
                push @{$names {$key}} => $value;
            }

            my $test_nr = 0;
          KEYS:
            foreach my $key (sort {$a cmp $b} keys %names) {
                my $exp_captures = @{$names {$key}};
                my $exp_message  = sprintf "%d capture%s named '%s'",
                                            $exp_captures,
                                            $exp_captures == 1 ? "" : "s", $key;
                my $name = "Number of captures named '$key'";
                my $exp  =  shift @exp;

                check_single_result output      => $output,
                                    test_nr     => ++ $test_nr,
                                    exp_result  => $exp,
                                    name        => $name,
                                    exp_message => $exp_message;
                ;
                return unless @exp;
                foreach my $j (keys @{$names {$key}}) {
                    my $value       = $names {$key} [$j];
                    my $name        = "Checking value of \$- {$key} [$j]";
                    my $exp_message = "\$- {$key} [$j] eq '$value'";
                    my $exp         = shift @exp;
                    check_single_result output      => $output,
                                        test_nr     => ++ $test_nr,
                                        exp_result  => $exp,
                                        name        => $name,
                                        exp_message => $exp_message;
                    ;
                    return unless @exp;
                }
            }

            my $name = "All expected captures accounted for";
            check_single_result output      => $output,
                                test_nr     => ++ $test_nr,
                                exp_result  => shift @exp,
                                name        => $name,
                                exp_message => $name
            ;
        }
    }
}

#
# Check the section testing positional parameters
#
my sub check_positional ($output, $exp, $match) {
    my $captures = $$match {captures} || [];
    subtest "Checking Positional Captures subtest" => sub {
        like $$output [0], qr /^# Subtest: Positional captures$/,
                           "Correct header";
        my @exp = split // => $exp;

        is reported_tests ($output), length ($exp), "Number of reported tests";

        foreach my $i (keys @exp) {
            my $test_nr = $i + 1;
            my $capture = $$captures [$i - 1];
            if ($capture && ref $capture) {$capture = $$capture [1]}

            my $name = $test_nr == 1 ? "Number of positional captures"
                                     : "Checking \$$i";
            my $exp_message = $test_nr == 1 ?
                                  @exp == 1 ? "No positional captures"
                                            : "Number of positional captures"
                                            : "\$$i eq '$capture'";

            check_single_result output      => $output,
                                test_nr     => $test_nr,
                                exp_result  => $exp [$i],
                                name        => $name,
                                exp_message => $exp_message;
            ;
        }
    }
}


sub run_tests (%args) {
    my $name      = $args {name};
    my $match     = $args {match};
    my $exp       = $args {exp};
    my $subject   = $$match {subject};
    my $pattern   = $$match {pattern};
    subtest ($name => sub {
        foreach my $info ([output    => 'Subroutine'],
                          [output_oo => 'OO Interface']) {
            my ($key, $subname) = @$info;
            if ($args {$key}) {
                my $output    = $args {output};
                my ($outer, $subtests, $trail) = split_into_subtests $output;
                my @exp = split /;/ => $exp;
                subtest ($subname => sub {
                    check_outer $outer, $match, $exp;
                    is (scalar @$subtests, scalar @exp,
                               "Expected number of subtests");
                    check_match      $$subtests [0], $exp [0], $match
                                                  if $exp [0];
                    check_named      $$subtests [1], $exp [1], $match
                                                  if $exp [1];
                    check_positional $$subtests [2], $exp [2], $match
                                                  if $exp [2];
                })
            }
        }
    })
}

1;


__END__
